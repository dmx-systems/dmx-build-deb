#!/bin/sh
# preinst script for dmx
#
# see: dh_installdeb(1)

set -e


## CAUTION! If commands in your hook script write to STDOUT,
## you may need to redirect output to STDERR (>&2) or some other
## place to avoid confusing debconf.  If you don't, it may cause
## a mysterious error even if the hook script exits with a return 
## status of zero!

echo "running $0 $1" >&2


# summary of how this script can be called:
#        * <new-preinst> `install'
#        * <new-preinst> `install' <old-version>
#        * <new-preinst> `upgrade' <old-version>
#        * <old-preinst> `abort-upgrade' <new-version>
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package

## Source debconf library.
. /usr/share/debconf/confmodule

case "$1" in
    install|upgrade)
    ## Get the name of the package
    PACKAGE="${DPKG_MAINTSCRIPT_PACKAGE}"
    DMVERSION='@@VERSION@@'

    ## Is this the headless package?
    HEADLESS_PACKAGE="$( echo "${PACKAGE}" | grep 'headless' )" || true

    ## Is this a desktop system?
    SOCKET_STATUS="$( netstat -lp 2>/dev/null | grep -E 'Xorg|Xwayland' | grep 'X11' )" || true
    PROCESS_STATUS="$( pgrep 'Xorg|Xwayland' )" || true

    echo "HEADLESS_PACKAGE=${HEADLESS_PACKAGE}" >&2
    echo "SOCKET_STATUS=${SOCKET_STATUS}" >&2
    echo "PROCESS_STATUS=${PROCESS_STATUS}" >&2

    ## Check system and ask user
    # if [ -z "${SOCKET_STATUS}" ] && [ -z "${PROCESS_STATUS}" ] && [ -z "${HEADLESS_PACKAGE}" ]; then
    if [ -n "${SOCKET_STATUS}" ] && [ -n "${PROCESS_STATUS}" ] && [ -z "${HEADLESS_PACKAGE}" ]; then
	## prompt headless warning
	db_input high dmx/headless_warning || true
        db_clear || true
	db_input high dmx/continue_installation || true
	db_go || true
	db_get dmx/continue_installation || true
        ANSWER="$RET"
	echo "continue_installation=<${ANSWER}>" >&2
	if [ "${ANSWER}" != "true" ]; then
    	    ## Remove the changes from the db.
    	    echo "Aborting $1." >&2
    	    db_purge || true
    	    ## Abort installation
    	    ## IMPORTANT: exit 0 will not cancel the installation process,
    	    ## but only exit from preinst and continue with installation.
    	    exit 1
	fi
    fi

    ###  FIXME
    ###  Backing up the db depends on the location of the db, which is a config parameter in config properties.
    ###  So in the funture we have to read that!
    DBDIR='/var/lib/dmx/dmx-db'
    BACKUPDATE="$( date +%F-%H:%M:%S )"
    ## check if dmx is already running and stop it then
    # systemctl is-active --quiet dmx.service && deb-systemd-invoke stop dmx
    if [ "$(systemctl is-active 'dmx.service')" ]; then
	# deb-systemd-invoke stop dmx.service >/dev/null 2>&1 || true
	deb-systemd-invoke stop 'dmx.service' >/dev/null || true
    fi
    ## was there a previously installed DMX
    INSTALLED_VERSION="$( dpkg -s ${PACKAGE} 2>/dev/null | sed -n 's/^Version: //p' | cut -d'~' -f1 )"
    PREVIOUSDBVERSION="$( if [ -d ${DBDIR} ]; then find ${DBDIR} -name ".dm-version.*" | cut -d'.' -f'3-' | sort -V | tail -n1; fi )"
    ## backup existing database
    if [ -d ${DBDIR} ]; then
        if [ -n "${PREVIOUSDBVERSION}" ]; then
            BACKUPDIR="${DBDIR}-${PREVIOUSDBVERSION}-backup-$BACKUPDATE"
        elif [ -n "${INSTALLED_VERSION}" ]; then
            BACKUPDIR="${DBDIR}-${INSTALLEDDBVERSION}-backup-$BACKUPDATE"
        else
            BACKUPDIR="${DBDIR}-preinst_${DMVERSION}-backup-$BACKUPDATE"
        fi
        cp -a ${DBDIR} ${BACKUPDIR}
	echo "Your existing database has been backed-up (copied) to ${BACKUPDIR}." >&2
    else
        mkdir ${DBDIR}
    fi
    # chown dmx:dmx ${DBDIR}
    chmod 750 ${DBDIR}
    touch ${DBDIR}/.dm-version.$DMVERSION
    ;;

    abort-upgrade)
    ;;

    *)
        echo "preinst called with unknown argument \`$1'" >&2
        exit 1
    ;;
esac

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#

exit 0
